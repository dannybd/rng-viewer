<!DOCTYPE html>
<html>
<head>
  <title>Explaining Nominative Determinism</title>
  <meta charset="UTF-8">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ²</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&amp;family=Open+Sans:wght@400;700&amp;display=swap" rel="stylesheet">
  <link href="https://d35iw2jmbg6ut8.cloudfront.net/static/css/main.b6b21d7e.chunk.css" rel="stylesheet">
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
  <link rel="stylesheet" href="static/style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.js"></script>
  <script src="static/rng-solver.js"></script>
</head>
<body class="theme-dark no-x">
<noscript>You need to enable JavaScript to run this website.</noscript>
<header>
  <h1><a href="?">Explaining Nominative Determinism</a></h1>
  <p>
    The Random Number Generator (RNG) behind <tt>Math.random()</tt> is cryptographically weak.
    <br>
    If we have just enough information, we can reverse-engineer the original RNG state,
    and deterministically crack the past and future dice rolls around our information.
    <br>
    Built by honu. Based on RNG research in
    <a href="https://blog.securityevaluators.com/xorshift128-backward-ff3365dc0c17">this blog post</a>,
    and immeasurable help from ubuntor and Astrid, including
    <a href="https://gist.github.com/xSke/c9d20dd09e640e33152c5f504582e1d9/">this gist</a>
    and
    <a href="https://github.com/xSke/resim/blob/main/rng_solver.py">this repo</a>.
  </p>
</header>
<div id="settings">
  <button id="lightdark" title="Toggle light and dark mode">ðŸŒ—</button><br>
</div>
<div id="loading"><h2><em>Loading...</em></h2></div>
<main>
  <pre id="test"></pre>
  <button id="divine" style="color: inherit;">Run divine rolls test</button>
</main>
<script type="text/javascript">

// Toggle light/dark mode
$('#lightdark').click(_ => {
  document.body.classList.toggle('theme-dark');
  document.body.classList.toggle('theme-light');
});

$('#loading').hide();
console._log = console.log;
console.log = (...x) => {
  $('#test').append(
    x.map(
      y => ['string', 'number', 'bigint'].includes(typeof(y))
        ? y
        : JSON.stringify(y, (_, v) => typeof(v) === 'bigint' ? v.toString() : v)
    ).join(' '),
    '\n',
  );
  console._log(...x);
};


function test() {
  const knowns = [
      0.08109881677206165,  // baseThirst
      [0.855381, 0.855382], // buoyancy
      [0.877, 0.879],       // patheticism
      null,                 // musclitude
      null,                 // divinity
      0.8836552885826778,   // moxie
      [0.551, 0.553],       // thwackability
  ];
  console.log('knowns:', knowns);
  // s0,s1 at baseThirst generation
  const expected_solution = [[1496009117674886285n, 15779009155937865159n]];
  console.log('Running solve_in_rng_order(knowns)...');
  const sol = solve_in_rng_order(knowns);
  console.log(`got solutions: ${sol}`);
  if (sol.toString() === expected_solution.toString()) {
    console.log('test success: quack enjoyable!');
  } else {
    console.log('test fail');
  }
  console.log('');
}

test();

function test2() {
  // https://rng.sibr.dev/?state=(15779009155937865159,16202637166048270229)+4
  // In Math.random() output order!
  const rolls = [
    // 0.8553818003268248,
    // 0.08109881677206165,
    // 0.4331553731381861,
    0.1805283222757248,
    0.9168731767791545,
    // split block
    0.2637553293627233,
    // 0.9692475075808971,
    // 0.034293735113851476,
    // 0.6220975442089625,
    // 0.13177880189820135,
    // 0.393173677080664,
  ];
  console.log('rolls:', rolls);
  console.log('Running solve_in_math_random_order(rolls)...');
  const results = solve_in_math_random_order(rolls);
  for (let {state, offset, crossesBlockBoundary} of results) {
    let rng = new Rng(state, offset);
    let url = rng.getStateURL();
    console.log(`got solution: <a target="_blank" href="${url}">${url}</a>`);
    console.log('Predicted next value:', rng.step(rolls.length));
    console.log('   Actual next value: 0.9692475075808971');
    if (!crossesBlockBoundary) {
      console.log(
        'Warning, does not cross a block boundary, so may be mis-aligned!',
      );
    }
  }
  console.log('');
}

test2();

function test3() {
  for (let i = 0; i < 64 * Math.random(); i++) {
    Math.random();
  }
  console.log('Finding current Math.random() state...');
  const rolls = [...Array(64).keys()].map(Math.random);
  console.log(`> testing with ${rolls.length} rolls:`, rolls);
  const results = solve_in_math_random_order(rolls);
  for (let {state, offset, crossesBlockBoundary} of results) {
    let rng = new Rng(state, offset);
    let url = rng.getStateURL();
    console.log(`got solution: <a target="_blank" href="${url}">${url}</a>`);
    console.log('Predicted next Math.random() value:', rng.step(rolls.length));
    console.log('   Actual next Math.random() value:', Math.random());
    if (crossesBlockBoundary) {
      console.log('Crosses block boundary, it is aligned!');
    } else {
      console.log(
        'Warning, does not cross a block boundary, so may be mis-aligned!',
      );
    }
  }
  console.log('');
}

test3();

function testDivine() {
  $('#divine').prop('disabled', true);
  function inner(slice) {
    const {min: start_time, max: end_time} = slice.map(x => x.timestamp)
      .reduce(
        (range, time) => {
          let min = range.min ?? time;
          let max = range.max ?? time;
          min = time < min ? time : min;
          max = time > max ? time : max;
          return {min, max};
        },
        {min: null, max: null},
      );

    const knowns = [];
    for (let {lower_bound: lo, upper_bound: hi} of slice) {
      if (lo === hi) {
        knowns.push(lo);
      } else if ((lo > 0) || (hi < 1)) {
        knowns.push([lo, hi]);
      } else {
        knowns.push(null);
      }
    }

    console.log(`Trying window ${start_time} - ${end_time}`);

    const solutions = solve_in_math_random_order(knowns);
    for (let {state, offset} of solutions) {
      let rng = new Rng(state, offset);
      for (let roll of slice) {
        if (roll && roll.index === 0) {
          // account for our indexing being the coords *before* consuming the roll
          rng.step(-1);
          console.log(
            `found event at ${roll.timestamp} (${roll.roll_name}): ` +
            `${rng.getStateStr()}, first roll ${rng.next()}`
          );
          break;
        }
        rng.step(1);
      }
    }
  }

  console.log('Running divine test...');

  const jsonURLPrefix =
    location.protocol === 'https:' ? '' : 'https://rng.sibr.dev/';
  $.get(jsonURLPrefix + 'static/test-divine-rolls.json', roll_log => {
    const start = performance.now();
    const window_size = 2800;
    const step_size = 100;

    const args = [];
    for (let window_pos = 0; window_pos < roll_log.length - window_size; window_pos += step_size) {
      let slice = roll_log.slice(window_pos, window_pos + window_size);
      args.push(slice);
    }

    for (let slice of args) {
      inner(slice);
    }
    const end = performance.now();
    console.log('');
    console.log(`Divine test executed in: ${(end - start) / 1000} seconds`);
    console.log('');
    $('#divine').prop('disabled', false);
  });

}

$('#divine').click(testDivine);

</script>
</body>
</html>
